package com.localizedjpa.compiler;

import com.squareup.javapoet.*;

import javax.annotation.processing.Filer;
import javax.lang.model.element.Modifier;
import java.io.IOException;
import java.util.List;
import java.util.Locale;

/**
 * Generates localized interface source files using JavaPoet.
 * 
 * <p>For each entity annotated with @LocalizedEntity, generates an interface
 * containing method signatures for all @Localized fields:
 * <ul>
 *   <li>{@code T getFieldName()} - get value for current locale</li>
 *   <li>{@code void setFieldName(T value)} - set value for current locale</li>
 *   <li>{@code T getFieldName(Locale locale)} - get value for specific locale</li>
 *   <li>{@code void setFieldName(T value, Locale locale)} - set value for specific locale</li>
 * </ul>
 */
public class InterfaceGenerator {

    private final Filer filer;

    public InterfaceGenerator(Filer filer) {
        this.filer = filer;
    }

    /**
     * Generates a localized interface for the given entity.
     *
     * @param packageName Package name of the entity
     * @param entityName Simple name of the entity class
     * @param localizedFields List of field names annotated with @Localized
     * @throws IOException If file cannot be written
     */
    public void generateInterface(String packageName, String entityName, 
                                   List<LocalizedFieldInfo> localizedFields) throws IOException {
        
        String interfaceName = entityName + "Localized";
        
        TypeSpec.Builder interfaceBuilder = TypeSpec.interfaceBuilder(interfaceName)
                .addModifiers(Modifier.PUBLIC)
                .addJavadoc("Generated interface for localized entity {@code $L}.\n", entityName)
                .addJavadoc("\n<p>Implement this interface to get type-safe access to localized fields.\n")
                .addJavadoc("This interface is auto-generated by the Localized JPA compiler.\n");

        // Add methods for each localized field
        for (LocalizedFieldInfo field : localizedFields) {
            addFieldMethods(interfaceBuilder, field);
        }

        TypeSpec interfaceSpec = interfaceBuilder.build();
        
        JavaFile javaFile = JavaFile.builder(packageName, interfaceSpec)
                .addFileComment("Generated by Localized JPA Compiler - do not modify")
                .indent("    ")
                .build();

        javaFile.writeTo(filer);
    }

    private void addFieldMethods(TypeSpec.Builder interfaceBuilder, LocalizedFieldInfo field) {
        String fieldName = field.name();
        TypeName fieldType = field.typeName();
        String capitalizedName = capitalize(fieldName);

        // 1. T getFieldName() - current locale
        interfaceBuilder.addMethod(MethodSpec.methodBuilder("get" + capitalizedName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .returns(fieldType)
                .addJavadoc("Gets the {@code $L} value for the current locale.\n", fieldName)
                .addJavadoc("@return The localized value, or null if not found\n")
                .build());

        // 2. void setFieldName(T value) - current locale
        interfaceBuilder.addMethod(MethodSpec.methodBuilder("set" + capitalizedName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addParameter(fieldType, "value")
                .addJavadoc("Sets the {@code $L} value for the current locale.\n", fieldName)
                .addJavadoc("@param value The value to set\n")
                .build());

        // 3. T getFieldName(Locale locale) - explicit locale
        interfaceBuilder.addMethod(MethodSpec.methodBuilder("get" + capitalizedName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .returns(fieldType)
                .addParameter(Locale.class, "locale")
                .addJavadoc("Gets the {@code $L} value for the specified locale.\n", fieldName)
                .addJavadoc("@param locale The target locale\n")
                .addJavadoc("@return The localized value, or null if not found\n")
                .build());

        // 4. void setFieldName(T value, Locale locale) - explicit locale
        interfaceBuilder.addMethod(MethodSpec.methodBuilder("set" + capitalizedName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addParameter(fieldType, "value")
                .addParameter(Locale.class, "locale")
                .addJavadoc("Sets the {@code $L} value for the specified locale.\n", fieldName)
                .addJavadoc("@param value The value to set\n")
                .addJavadoc("@param locale The target locale\n")
                .build());
    }

    private String capitalize(String str) {
        return StringUtils.capitalize(str);
    }

    /**
     * Record holding information about the @Column annotation.
     */
    public record ColumnInfo(Integer length, Integer precision, Integer scale, 
                           Boolean nullable, Boolean unique, String columnDefinition) {
        public static ColumnInfo empty() {
            return new ColumnInfo(null, null, null, null, null, null);
        }
    }

    /**
     * Record holding information about a localized field.
     */
    public record LocalizedFieldInfo(String name, TypeName typeName, boolean fallback, 
                                   ColumnInfo columnInfo, List<AnnotationSpec> additionalAnnotations) {
        
        // Compact constructor for backward compatibility during refactoring
        public LocalizedFieldInfo(String name, TypeName typeName, boolean fallback) {
            this(name, typeName, fallback, ColumnInfo.empty(), List.of());
        }
    }
}
